CREATE TYPE instance_status AS ENUM ('live', 'dead');

CREATE TABLE IF NOT EXISTS instances (
	id varchar(64) PRIMARY KEY,
	last_at timestamptz NOT NULL DEFAULT NOW(),
	status instance_status NOT NULL DEFAULT 'live'
);

CREATE TABLE IF NOT EXISTS schedules (
	schedule_id varchar(64) PRIMARY KEY,
	schedule varchar(1024) NOT NULL,
	next_id bigint NULL,
	next_at bigint NULL,
	repeat bigint NULL,
	until bigint NULL,
	inactive boolean NOT NULL DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS jobs (
	id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	created_at timestamptz NOT NULL DEFAULT NOW(),
	protocol varchar(16) NOT NULL,
	meta jsonb NOT NULL,
	headers jsonb NULL,
	body BYTEA NULL,
	schedule_id varchar(64) NULL REFERENCES schedules (schedule_id) MATCH SIMPLE
);

CREATE TABLE IF NOT EXISTS scheduled (
	id bigint NOT NULL PRIMARY KEY REFERENCES jobs(id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
	at bigint NOT NULL,
	retry int NOT NULL DEFAULT 0,
	is_retried bool NOT NULL GENERATED ALWAYS AS (retry > 0) STORED
);

CREATE TABLE IF NOT EXISTS enqueued (
	id bigint NOT NULL PRIMARY KEY REFERENCES jobs (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
	retry int NOT NULL DEFAULT 0,
	instance_id varchar(64) NULL,
	lock_at timestamptz NULL
);

CREATE TYPE  processed_status AS ENUM ('completed', 'failed', 'cancelled');

CREATE TABLE IF NOT EXISTS processed (
	id bigint NOT NULL PRIMARY KEY REFERENCES jobs (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
	retry int NOT NULL DEFAULT 0,
	instance_id varchar(64) NOT NULL,
	at timestamptz NOT NULL DEFAULT NOW(),
	status processed_status NOT NULL,
	meta jsonb NOT NULL,
	headers jsonb NULL,
	body BYTEA NULL
);

CREATE TYPE history_status AS ENUM (
	'scheduled',
	'enqueued',
	'assigned',
	'retried',
	'completed',
	'failed',
	'cancelled'
);

CREATE TABLE IF NOT EXISTS history (
	id bigint NOT NULL REFERENCES jobs (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
	retry int NOT NULL DEFAULT 0,
	instance_id varchar(64) NOT NULL,
	at timestamptz NOT NULL DEFAULT NOW(),
	status history_status NOT NULL,
	message text NULL
);

CREATE INDEX IF NOT EXISTS ix_enqueued_retry_id ON enqueued
	USING btree (retry ASC NULLS LAST, id ASC NULLS LAST)
	WHERE lock_at IS NULL;


-- select 'retried' as name, count(*) as count from public.scheduled where is_retried
-- union all
-- select 'scheduled' as name, count(*) as count from public.scheduled where not is_retried
-- union all
-- select 'enqueued' as name, count(*) as count from public.enqueued where lock_at is null
-- union all
-- select 'processing' as name, count(*) as count from public.enqueued where lock_at is not null
-- union all 
-- select status::text as name, count(*) as count from public.processed group by status;

select (CASE is_retried WHEN TRUE THEN 'retried'::history_status ELSE 'scheduled'::history_status END) as name, count(*) as count from public.scheduled group by is_retried
union all
select (CASE lock_at is null WHEN TRUE THEN 'enqueued'::history_status ELSE 'assigned'::history_status END) as name, count(*) as count from public.enqueued group by lock_at is null
union all
select status::text::history_status as name, count(*) as count from public.processed group by status;

WITH a AS (
	INSERT INTO jobs(protocol, meta, headers, body)		
		SELECT 'none' as protocol,
		'{"retry": "none", "timeout": 3000, "protocol": "none"}'::jsonb as meta,
		'{}'::jsonb as headers,
		null as body
		from generate_Series(1, 1000) s
	RETURNING id
)
INSERT INTO enqueued SELECT id FROM a RETURNING id

SELECT p.id, p.status, p.at - j.created_at, p.instance_id FROM processed p
inner join jobs j on j.id = p.id
order by p.id desc
